{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Embedded System Cook Book \u00b6 Ideia do livro \u00e9 de ter receitas de como desenvolver firmware para sistemas embarcados, as receitas ser\u00e3o de \"aplica\u00e7\u00f5es\", \"sensores\" e \"atuadores\" sem pensar muito no HW, mais focado para o firmware. misc sensores atuadores dsp","title":"Home"},{"location":"#embedded-system-cook-book","text":"Ideia do livro \u00e9 de ter receitas de como desenvolver firmware para sistemas embarcados, as receitas ser\u00e3o de \"aplica\u00e7\u00f5es\", \"sensores\" e \"atuadores\" sem pensar muito no HW, mais focado para o firmware. misc sensores atuadores dsp","title":"Embedded System Cook Book"},{"location":"misc/digital-input-irq/","text":"Digital Input - IRQ \u00b6 read before This complements Digital Input - Pooling . General information and hardware is describe there. The use of interruption makes the code react to event on the pin (High -> Low/ Low -> High/ High/ Low). The advantage of using interrupt is: Avoid losing information (pin value change) Prioritization of events Entering in low power mode Ever time an event occurs on the pin, the peripheral sends a signal to NVIC , hardware responsible to handle Interruptions Request (IRQ), and the NVIC acts on the CORE to disrupt the normal code flow and execute a function that is associated to this IRQ, this functions is frequently called: Handler or callbacks . When the function returns, the core goes back to the normal code flow, with no loss of data. Interruption is a little more complicated than this, please read: .... Hardware \u00b6 See Digital Input - Pooling Firmware \u00b6 Steps to enable interruption on digital pin input: Enable system clock/ board configurations. Enable the peripheral Configure the pin on peripheral: Pin as input Pull-Up/ Pull-Down (depends on HW) Configure interruption (edge/ level) Enable interruption Configure NVIC: IRQ peripheral priority Enable peripheral IRQ Write a function that will handle the interruption Example Code \u00b6 SAME70 Firmware example for SAME70 with internal Pull-Up and Falling Edge interruption to read a push button connected to the pin PA11 . Callback function but_callback will be called every time the button is pressed. #define BUT_PIO PIOA #define BUT_PIO_ID ID_PIOA #define BUT_IDX 11 #define BUT_IDX_MASK (1 << BUT_IDX) #define BUT_SETTINGS PIO_PULLUP // this function is called when button is pressed void but_callback ( void ){ } int main ( void ){ // init system sysclk_init (); // enable and configure peripheral pmc_enable_periph_clk ( BUT_PRO_ID ); pio_configure ( BUT_PIO , PIO_INPUT , BUT_IDX_MASK , BUT_SETTINGS ); // configure interruption on pin with falling edge pio_handler_set ( BUT_PIO , BUT_PIO_ID , BUT_IDX_MASK , PIO_IT_FALL_EDGE , but_callback ); // enable peripheral interruption pio_enable_interrupt ( BUT_PIO , BUT_IDX_MASK ); // set peripheral priority and enable IRQ on NVIC NVIC_SetPriority ( BUT_PIO_ID , 4 ); NVIC_EnableIRQ ( BUT_PIO_ID ); while ( 1 ){ // note that there is no code on while! // but if the button is pressed, the // function but_callback will be called by // hardware! } } Multiple events It is possible to react to multiple events on the pin, example: Falling edge and rising edge, this would create an interruption when the button is pressed and released. This interruption would leave to the same callback function but_callback , there is two way to discovery by what event you got in the function: read the actual pin value, if 1 you get on the function by a rising edge, if 0 you get by a falling edge. some peripherals can inform by a status register what triggered the IRQ. On this code: void but_callback (void){ + if (pio_get (BUT_PIO, PIO_INPUT, BUT_IDX_MASK)){ + // rising edge + } else { + // falling edge + } } // configure interruption on pin with falling edge pio_handler_set (BUT_PIO, BUT_PIO_ID, BUT_IDX_MASK, - PIO_IT_FALL_EDGE, but_callback); + PIO_IT_FALL_EDGE | PIO_IT_RISE_EDGE, but_callback); Arduino Firmware example for Arduino with internal Pull-Up and Falling Edge interruption to read a push button connected to the pin 7 . Callback function but_callback will be called every time the button is pressed. const byte interruptPin = 7 ; volatile byte state = LOW ; void setup () { pinMode ( interruptPin , INPUT_PULLUP ); attachInterrupt ( digitalPinToInterrupt ( interruptPin ), but_callback , CHANGE ); } void loop () { // note that there is no code on loop! // but if the button is pressed, the // function but_callback will be called by // hardware! } // this function is called when button is pressed void but_callback ( void ){ }","title":"Digital Input - IRQ"},{"location":"misc/digital-input-irq/#digital-input-irq","text":"read before This complements Digital Input - Pooling . General information and hardware is describe there. The use of interruption makes the code react to event on the pin (High -> Low/ Low -> High/ High/ Low). The advantage of using interrupt is: Avoid losing information (pin value change) Prioritization of events Entering in low power mode Ever time an event occurs on the pin, the peripheral sends a signal to NVIC , hardware responsible to handle Interruptions Request (IRQ), and the NVIC acts on the CORE to disrupt the normal code flow and execute a function that is associated to this IRQ, this functions is frequently called: Handler or callbacks . When the function returns, the core goes back to the normal code flow, with no loss of data. Interruption is a little more complicated than this, please read: ....","title":"Digital Input - IRQ"},{"location":"misc/digital-input-irq/#hardware","text":"See Digital Input - Pooling","title":"Hardware"},{"location":"misc/digital-input-irq/#firmware","text":"Steps to enable interruption on digital pin input: Enable system clock/ board configurations. Enable the peripheral Configure the pin on peripheral: Pin as input Pull-Up/ Pull-Down (depends on HW) Configure interruption (edge/ level) Enable interruption Configure NVIC: IRQ peripheral priority Enable peripheral IRQ Write a function that will handle the interruption","title":"Firmware"},{"location":"misc/digital-input-irq/#example-code","text":"SAME70 Firmware example for SAME70 with internal Pull-Up and Falling Edge interruption to read a push button connected to the pin PA11 . Callback function but_callback will be called every time the button is pressed. #define BUT_PIO PIOA #define BUT_PIO_ID ID_PIOA #define BUT_IDX 11 #define BUT_IDX_MASK (1 << BUT_IDX) #define BUT_SETTINGS PIO_PULLUP // this function is called when button is pressed void but_callback ( void ){ } int main ( void ){ // init system sysclk_init (); // enable and configure peripheral pmc_enable_periph_clk ( BUT_PRO_ID ); pio_configure ( BUT_PIO , PIO_INPUT , BUT_IDX_MASK , BUT_SETTINGS ); // configure interruption on pin with falling edge pio_handler_set ( BUT_PIO , BUT_PIO_ID , BUT_IDX_MASK , PIO_IT_FALL_EDGE , but_callback ); // enable peripheral interruption pio_enable_interrupt ( BUT_PIO , BUT_IDX_MASK ); // set peripheral priority and enable IRQ on NVIC NVIC_SetPriority ( BUT_PIO_ID , 4 ); NVIC_EnableIRQ ( BUT_PIO_ID ); while ( 1 ){ // note that there is no code on while! // but if the button is pressed, the // function but_callback will be called by // hardware! } } Multiple events It is possible to react to multiple events on the pin, example: Falling edge and rising edge, this would create an interruption when the button is pressed and released. This interruption would leave to the same callback function but_callback , there is two way to discovery by what event you got in the function: read the actual pin value, if 1 you get on the function by a rising edge, if 0 you get by a falling edge. some peripherals can inform by a status register what triggered the IRQ. On this code: void but_callback (void){ + if (pio_get (BUT_PIO, PIO_INPUT, BUT_IDX_MASK)){ + // rising edge + } else { + // falling edge + } } // configure interruption on pin with falling edge pio_handler_set (BUT_PIO, BUT_PIO_ID, BUT_IDX_MASK, - PIO_IT_FALL_EDGE, but_callback); + PIO_IT_FALL_EDGE | PIO_IT_RISE_EDGE, but_callback); Arduino Firmware example for Arduino with internal Pull-Up and Falling Edge interruption to read a push button connected to the pin 7 . Callback function but_callback will be called every time the button is pressed. const byte interruptPin = 7 ; volatile byte state = LOW ; void setup () { pinMode ( interruptPin , INPUT_PULLUP ); attachInterrupt ( digitalPinToInterrupt ( interruptPin ), but_callback , CHANGE ); } void loop () { // note that there is no code on loop! // but if the button is pressed, the // function but_callback will be called by // hardware! } // this function is called when button is pressed void but_callback ( void ){ }","title":"Example Code"},{"location":"misc/digital-input-pooling/","text":"Digital Input - Pooling \u00b6 Digital input output (I/O) is the most simple way to read from external world. This signal can assume only two states: On/OFF, 1 / 0 , High / Low . most common uses Buttons (push/ slider/ dip switch) Signal pulse (encoder) ... The peripheral that allows us to read a digital value is common named: Parallel I/O - PIO General-Purpose I/O - GPIO Normally this peripherals controls more than one pin and each microcontroller has several instances of the same peripheral, to control more pins. Each pin can be configured independent. Microchip SAM Microchip SAM microcontrollers called this as PIO, each instance of the PIO is called PIO A , PIO B , PIO C , ... each PIO can controll up to 32 independents pins. Hardware \u00b6 This examples shows how to read a button, but can be applied to others digital components. There is two-way to use a button: with Pull-Up or Pull-Down. Most peripherals allow to enable a internal Pull-UP/Pull-Down resistor, with no need to connect resistors to the uC. Internal Pull-Up Best solution (reduces the risk of burning, uses fewer components) Setup: Connect button to pin and to gnd Need to configure Pull-Up on the peripheral. No need to external resistor Read 1 when not pressed and 0 when pressed. External Pull-Up Setup: Connect button to pin and to gnd Add a parallel resistor to VCC must respect max pin voltage Read 1 when not pressed and 0 when pressed. Warning You must respect the VCC of your system. Internal Pull-Down TODO Read 0 when not pressed and 1 when pressed. External Pull-Down TODO Read 0 when not pressed and 1 when pressed. Firmware \u00b6 Steps to read a simple digital data: Enable system clock/ board configs. Enable the peripheral Configure on the peripheral: Pin as input As need: Pull-Up/ Pull-Down Read the data Code \u00b6 Microchip SAME70 Firmware example for SAME70 with internal Pull-Up to read a push button connected to the pin PA11 . mbed Example for mbed with internal Pull-Up to read a push button connected to the pin SW2 . Reference: https://os.mbed.com/docs/mbed-os/v6.2/apis/digitalin.html #include \"mbed.h\" DigitalIn but_pin ( SW2 ); // change this to the button on your board int main () { // check mypin object is initialized and connected to a pin if ( but_pin . is_connected ()) { printf ( \"mypin is connected and initialized! \\n\\r \" ); } but_pin . mode ( PullUp ); while ( 1 ) { if ( but_pin . read ()) { // button not pressed else { // button pressed } ThisThread :: sleep_for ( 250 ); } } Arduino Example for arduino with internal Pull-Up to read a push button connected to the pin 7 . Referece: https://www.arduino.cc/en/Reference/DigitalRead&usg=ALkJrhirTmK1 ... // pushbutton connected to digital pin 7 int inPin = 7 ; void setup () { // sets the digital pin 7 as input pinMode ( inPin , INPUT_PULLUP ); } void loop () { if ( digitalRead ( inPin )) { // button not pressed } else { // button pressed } }","title":"Digital Input - Pooling"},{"location":"misc/digital-input-pooling/#digital-input-pooling","text":"Digital input output (I/O) is the most simple way to read from external world. This signal can assume only two states: On/OFF, 1 / 0 , High / Low . most common uses Buttons (push/ slider/ dip switch) Signal pulse (encoder) ... The peripheral that allows us to read a digital value is common named: Parallel I/O - PIO General-Purpose I/O - GPIO Normally this peripherals controls more than one pin and each microcontroller has several instances of the same peripheral, to control more pins. Each pin can be configured independent. Microchip SAM Microchip SAM microcontrollers called this as PIO, each instance of the PIO is called PIO A , PIO B , PIO C , ... each PIO can controll up to 32 independents pins.","title":"Digital Input - Pooling"},{"location":"misc/digital-input-pooling/#hardware","text":"This examples shows how to read a button, but can be applied to others digital components. There is two-way to use a button: with Pull-Up or Pull-Down. Most peripherals allow to enable a internal Pull-UP/Pull-Down resistor, with no need to connect resistors to the uC. Internal Pull-Up Best solution (reduces the risk of burning, uses fewer components) Setup: Connect button to pin and to gnd Need to configure Pull-Up on the peripheral. No need to external resistor Read 1 when not pressed and 0 when pressed. External Pull-Up Setup: Connect button to pin and to gnd Add a parallel resistor to VCC must respect max pin voltage Read 1 when not pressed and 0 when pressed. Warning You must respect the VCC of your system. Internal Pull-Down TODO Read 0 when not pressed and 1 when pressed. External Pull-Down TODO Read 0 when not pressed and 1 when pressed.","title":"Hardware"},{"location":"misc/digital-input-pooling/#firmware","text":"Steps to read a simple digital data: Enable system clock/ board configs. Enable the peripheral Configure on the peripheral: Pin as input As need: Pull-Up/ Pull-Down Read the data","title":"Firmware"},{"location":"misc/digital-input-pooling/#code","text":"Microchip SAME70 Firmware example for SAME70 with internal Pull-Up to read a push button connected to the pin PA11 . mbed Example for mbed with internal Pull-Up to read a push button connected to the pin SW2 . Reference: https://os.mbed.com/docs/mbed-os/v6.2/apis/digitalin.html #include \"mbed.h\" DigitalIn but_pin ( SW2 ); // change this to the button on your board int main () { // check mypin object is initialized and connected to a pin if ( but_pin . is_connected ()) { printf ( \"mypin is connected and initialized! \\n\\r \" ); } but_pin . mode ( PullUp ); while ( 1 ) { if ( but_pin . read ()) { // button not pressed else { // button pressed } ThisThread :: sleep_for ( 250 ); } } Arduino Example for arduino with internal Pull-Up to read a push button connected to the pin 7 . Referece: https://www.arduino.cc/en/Reference/DigitalRead&usg=ALkJrhirTmK1 ... // pushbutton connected to digital pin 7 int inPin = 7 ; void setup () { // sets the digital pin 7 as input pinMode ( inPin , INPUT_PULLUP ); } void loop () { if ( digitalRead ( inPin )) { // button not pressed } else { // button pressed } }","title":"Code"},{"location":"misc/digital-output/","text":"Digital Output \u00b6 Digital output is the most simple way to control the external world. This signal can assume only two states: On/OFF, 1 / 0 , High / Low . most common uses LED DC Motor Buzzer ... The peripheral that allows us to read a digital value is common named: Parallel I/O - PIO General-Purpose I/O - GPIO Peripheral Read more about this peripheral on Peripheral-PIO . Hardware \u00b6 This examples shows how to control a LED, but can be apply to others digital components. This example shows on how to control a LED with a microcontroller, the series resistor limits the electric current. Drive in Best solution (reduces the risk of burning as normally input accept electric current is higher than output current) Connect LED to resistor to VCC Write 0 to pin light up LED, 1 turn off. Drive out Warning You must respect the VCC of your system. You must check the resistor value to your system. Firmware \u00b6 Steps to simple control a PIO pin: Enable system clock/ board configs. Enable the peripheral Configure the Pin as output Control pin (High/ Low) Example Code \u00b6 Microchip SAME70 Example for SAME70 blink an LED with drive in connection on pin `PC8``. #define LED_PIO PIOC #define LED_PIO_ID ID_PIOC #define LED_IDX 8 #define LED_IDX_MASK (1 << LED_IDX) #define LED_CONFIG PIO_DEFAULT int main ( void ){ sysclk_init (); // initialize digital pin LED_IDX as an output. pmc_enable_periph_clk ( LED_PIO_ID ); pio_configure ( LED_PIO , PIO_OUTPUT_0 , LED_IDX_MASK , PIO_DEFAULT ); while ( 1 ){ // drive pin low - turns led on pio_clear ( LED_PIO , LED_IDX_MASK ); delay_ms ( 100 ); // drive pin high - turns led off pio_set ( LED_PIO , LED_IDX_MASK ); delay_ms ( 100 ); } Arduino // pushbutton connected to digital pin 7 int LED_PIN = 5 ; void setup () { // initialize digital pin LED_PIN as an output. pinMode ( LED_PIN , OUTPUT ); } void loop () { // drive pin low - turns led on digitalWrite ( LED_PIN , LOW ); delay ( 100 ); // drive pin high - turns led off digitalWrite ( LED_PIN , HIGH ); delay ( 100 ); }","title":"Digital Output"},{"location":"misc/digital-output/#digital-output","text":"Digital output is the most simple way to control the external world. This signal can assume only two states: On/OFF, 1 / 0 , High / Low . most common uses LED DC Motor Buzzer ... The peripheral that allows us to read a digital value is common named: Parallel I/O - PIO General-Purpose I/O - GPIO Peripheral Read more about this peripheral on Peripheral-PIO .","title":"Digital Output"},{"location":"misc/digital-output/#hardware","text":"This examples shows how to control a LED, but can be apply to others digital components. This example shows on how to control a LED with a microcontroller, the series resistor limits the electric current. Drive in Best solution (reduces the risk of burning as normally input accept electric current is higher than output current) Connect LED to resistor to VCC Write 0 to pin light up LED, 1 turn off. Drive out Warning You must respect the VCC of your system. You must check the resistor value to your system.","title":"Hardware"},{"location":"misc/digital-output/#firmware","text":"Steps to simple control a PIO pin: Enable system clock/ board configs. Enable the peripheral Configure the Pin as output Control pin (High/ Low)","title":"Firmware"},{"location":"misc/digital-output/#example-code","text":"Microchip SAME70 Example for SAME70 blink an LED with drive in connection on pin `PC8``. #define LED_PIO PIOC #define LED_PIO_ID ID_PIOC #define LED_IDX 8 #define LED_IDX_MASK (1 << LED_IDX) #define LED_CONFIG PIO_DEFAULT int main ( void ){ sysclk_init (); // initialize digital pin LED_IDX as an output. pmc_enable_periph_clk ( LED_PIO_ID ); pio_configure ( LED_PIO , PIO_OUTPUT_0 , LED_IDX_MASK , PIO_DEFAULT ); while ( 1 ){ // drive pin low - turns led on pio_clear ( LED_PIO , LED_IDX_MASK ); delay_ms ( 100 ); // drive pin high - turns led off pio_set ( LED_PIO , LED_IDX_MASK ); delay_ms ( 100 ); } Arduino // pushbutton connected to digital pin 7 int LED_PIN = 5 ; void setup () { // initialize digital pin LED_PIN as an output. pinMode ( LED_PIN , OUTPUT ); } void loop () { // drive pin low - turns led on digitalWrite ( LED_PIN , LOW ); delay ( 100 ); // drive pin high - turns led off digitalWrite ( LED_PIN , HIGH ); delay ( 100 ); }","title":"Example Code"},{"location":"sensors/hc-sr04/","text":"HC SR04 \u00b6 Ultrasonic sonar distance sensor with resolution from 2 cm to 400 cm with a max accuracy of 3 mm. Common uses Robotics (object detection, distance calculation) Presence detection References datasheet https://www.sparkfun.com/products/15569 https://www.adafruit.com/product/3942 https://create.arduino.cc/projecthub/projects/tags/ultrasonic When request by the trigger pin , the sensor send a ultrasonic train pulse (8 pulses at 40 Khz) over it speaker and waiting to receive the sound on microphone, the sensor than returns the time that the pulse took to travel on the echo pin, knowing the sound velocity (350 m/s) is possible to calculate the object distance: object distance (m) = time * 350 / 2 object distance (m) = time * 350 / 2 note: The sensor returns the total travel time, so it is necessary to divide the distance by 2. The sensor has the fallowing interfaces/pins: VCC : 5V GND : Ground IN Trigger : uC sends a 10us pulse to start a new range measurement OUT Echo: Is a pulse sent by the sensor that has width proportional to the time Hardware \u00b6 pin x : Microcontroller Input pin y : Microcontroller Output Warning This sensor has a 5V interface, on this schematic we do a voltage division to reach 3.3V on the input pin, please check you uC values. Firmware \u00b6 You must configure: The pin that is connected to the Trigger as digital output (pin y). the pin that is connected to the Echo as digital input (pin x) There are several ways to interface with this sensor, it can be done only by software or by using time peripherals. Using peripherals to count time allows the firmware to perform more actions besides interact with the sensor and increase system resolution, this is a most go if the system wants to read more than one sensor at the same time. bare metal - no extra timer counter Configure Trigger and Echo pins respective as output and input Configure core delay function To start a new measurement generate a 10us pulse on the Trigger pin Do a while on the Echo pin waiting it to get High Do a while on the Echo pin waiting it to get low : add a nano seccond delay on the while count the cycles With the count we can calculate the time and then the distance Pins used on this example: PC8 : Trigger PD20 : Echo // Trigger pin #define TRIG_PIO PIOC #define TRIG_PIO_ID ID_PIOC #define TRIG_IDX 8 #define TRIG_IDX_MASK (1 << TRIG_IDX) // Echo pin #define ECHO_PIO PIOD #define ECHO_PIO_ID ID_PIOD #define ECHO_IDX 20 #define ECHO_IDX_MASK (1 << ECHO_IDX) #define SOUND_VEL 350 void hcsr04_init ( void ) {...}; void hcsr04_trig ( void ) { pio_set ( TRIG_PIO , TRIG_IDX_MASK ); delay_us ( 10 ); pio_clear ( TRIG_PIO , TRIG_IDX_MASK ); } void main ( void ) { // init system sysclk_init (); // sensor pins init hcsr04_init (); // init delay delay_init ( sysclk_get_cpu_hz ()); while ( 1 ) { // start measurement hcsr04_trig (); // wait for pulse init while ( pio_get ( ECHO_PIN , PIO_INPUT , ECHO_IDX_MASK ) == 0 ) {} // pulse has started unit32_t count = 0 ; while ( pio_get ( ECHO_PIN , PIO_INPUT , ECHO_IDX_MASK ) == 1 ) { delay_us ( 1 ); count ++ ; } // delay is microsecond float time = count * 0.0001 ; uint32_t distance = time * SOUND_VEL / 2.0 ; // delay for a new mes delay_ms ( 10 ); } } Resolution Usually vendors software framework wouldn't provide software delay for a period less than nano second. The resolution of this code is limited to the delay_us(1) used to calculate the pulse time. This implies in a resolution of 17.5 mm in distance that is higher than the resolution of sensor (3 mm). Solutions: Use a lower delay (can be done by nasm) Use systick to calculate time Use timercounter peripheral to count time Timeout This implementation don't have timeout on the echo signal, some time the sensor won`t generate an echo pulse and that could lead the firmware to be stuck. Solutions: Add a software timeout on both while Use systick to timeout Use an RTOS that has timeout mechanisms Example on how to do by software: +#define TIMEOUT_US 100 // wait for pulse init +uint8_t timeout = 0; +uint32_t timeout_count = 0; while (pio_get (ECHO_PIN, PIO_INPUT, ECHO_IDX_MASK) == 0) { + if (timeout_count++ > TIMEOUT_US) { + timeout = 1; + break; + } + + delay_us(1); } +if (timeout == 0) { while (pio_get (ECHO_PIN, PIO_INPUT, ECHO_IDX_MASK) == 1) { .... +}","title":"HC SR04"},{"location":"sensors/hc-sr04/#hc-sr04","text":"Ultrasonic sonar distance sensor with resolution from 2 cm to 400 cm with a max accuracy of 3 mm. Common uses Robotics (object detection, distance calculation) Presence detection References datasheet https://www.sparkfun.com/products/15569 https://www.adafruit.com/product/3942 https://create.arduino.cc/projecthub/projects/tags/ultrasonic When request by the trigger pin , the sensor send a ultrasonic train pulse (8 pulses at 40 Khz) over it speaker and waiting to receive the sound on microphone, the sensor than returns the time that the pulse took to travel on the echo pin, knowing the sound velocity (350 m/s) is possible to calculate the object distance: object distance (m) = time * 350 / 2 object distance (m) = time * 350 / 2 note: The sensor returns the total travel time, so it is necessary to divide the distance by 2. The sensor has the fallowing interfaces/pins: VCC : 5V GND : Ground IN Trigger : uC sends a 10us pulse to start a new range measurement OUT Echo: Is a pulse sent by the sensor that has width proportional to the time","title":"HC SR04"},{"location":"sensors/hc-sr04/#hardware","text":"pin x : Microcontroller Input pin y : Microcontroller Output Warning This sensor has a 5V interface, on this schematic we do a voltage division to reach 3.3V on the input pin, please check you uC values.","title":"Hardware"},{"location":"sensors/hc-sr04/#firmware","text":"You must configure: The pin that is connected to the Trigger as digital output (pin y). the pin that is connected to the Echo as digital input (pin x) There are several ways to interface with this sensor, it can be done only by software or by using time peripherals. Using peripherals to count time allows the firmware to perform more actions besides interact with the sensor and increase system resolution, this is a most go if the system wants to read more than one sensor at the same time. bare metal - no extra timer counter Configure Trigger and Echo pins respective as output and input Configure core delay function To start a new measurement generate a 10us pulse on the Trigger pin Do a while on the Echo pin waiting it to get High Do a while on the Echo pin waiting it to get low : add a nano seccond delay on the while count the cycles With the count we can calculate the time and then the distance Pins used on this example: PC8 : Trigger PD20 : Echo // Trigger pin #define TRIG_PIO PIOC #define TRIG_PIO_ID ID_PIOC #define TRIG_IDX 8 #define TRIG_IDX_MASK (1 << TRIG_IDX) // Echo pin #define ECHO_PIO PIOD #define ECHO_PIO_ID ID_PIOD #define ECHO_IDX 20 #define ECHO_IDX_MASK (1 << ECHO_IDX) #define SOUND_VEL 350 void hcsr04_init ( void ) {...}; void hcsr04_trig ( void ) { pio_set ( TRIG_PIO , TRIG_IDX_MASK ); delay_us ( 10 ); pio_clear ( TRIG_PIO , TRIG_IDX_MASK ); } void main ( void ) { // init system sysclk_init (); // sensor pins init hcsr04_init (); // init delay delay_init ( sysclk_get_cpu_hz ()); while ( 1 ) { // start measurement hcsr04_trig (); // wait for pulse init while ( pio_get ( ECHO_PIN , PIO_INPUT , ECHO_IDX_MASK ) == 0 ) {} // pulse has started unit32_t count = 0 ; while ( pio_get ( ECHO_PIN , PIO_INPUT , ECHO_IDX_MASK ) == 1 ) { delay_us ( 1 ); count ++ ; } // delay is microsecond float time = count * 0.0001 ; uint32_t distance = time * SOUND_VEL / 2.0 ; // delay for a new mes delay_ms ( 10 ); } } Resolution Usually vendors software framework wouldn't provide software delay for a period less than nano second. The resolution of this code is limited to the delay_us(1) used to calculate the pulse time. This implies in a resolution of 17.5 mm in distance that is higher than the resolution of sensor (3 mm). Solutions: Use a lower delay (can be done by nasm) Use systick to calculate time Use timercounter peripheral to count time Timeout This implementation don't have timeout on the echo signal, some time the sensor won`t generate an echo pulse and that could lead the firmware to be stuck. Solutions: Add a software timeout on both while Use systick to timeout Use an RTOS that has timeout mechanisms Example on how to do by software: +#define TIMEOUT_US 100 // wait for pulse init +uint8_t timeout = 0; +uint32_t timeout_count = 0; while (pio_get (ECHO_PIN, PIO_INPUT, ECHO_IDX_MASK) == 0) { + if (timeout_count++ > TIMEOUT_US) { + timeout = 1; + break; + } + + delay_us(1); } +if (timeout == 0) { while (pio_get (ECHO_PIN, PIO_INPUT, ECHO_IDX_MASK) == 1) { .... +}","title":"Firmware"},{"location":"sensors/template-sensors/","text":"Sensor name \u00b6 Short Explanation most common uses Commum uses cases references internal reference external reference Long sensor explanation How to read the sensor? Peripherals use Hardware \u00b6 Hardware connection example Firmware \u00b6 Steps to read a simple digital data: Enable system clock/ board configs. Enable the peripheral Configure on the peripheral: Pin as input As need: Pull-Up/ Pull-Down Read the data Code \u00b6 Microchip SAME70 Firmware example for SAME70 with internal Pull-Up to read a push button connected to the pin PA11 . mbed Example for mbed with internal Pull-Up to read a push button connected to the pin SW2 . Reference: https://os.mbed.com/docs/mbed-os/v6.2/apis/digitalin.html #include \"mbed.h\" DigitalIn but_pin ( SW2 ); // change this to the button on your board int main () { // check mypin object is initialized and connected to a pin if ( but_pin . is_connected ()) { printf ( \"mypin is connected and initialized! \\n\\r \" ); } but_pin . mode ( PullUp ); while ( 1 ) { if ( but_pin . read ()) { // button not pressed else { // button pressed } ThisThread :: sleep_for ( 250 ); } } Arduino Example for arduino with internal Pull-Up to read a push button connected to the pin 7 . Referece: https://www.arduino.cc/en/Reference/DigitalRead&usg=ALkJrhirTmK1 ... // pushbutton connected to digital pin 7 int inPin = 7 ; void setup () { // sets the digital pin 7 as input pinMode ( inPin , INPUT_PULLUP ); } void loop () { if ( digitalRead ( inPin )) { // button not pressed } else { // button pressed } }","title":"Sensor name"},{"location":"sensors/template-sensors/#sensor-name","text":"Short Explanation most common uses Commum uses cases references internal reference external reference Long sensor explanation How to read the sensor? Peripherals use","title":"Sensor name"},{"location":"sensors/template-sensors/#hardware","text":"Hardware connection example","title":"Hardware"},{"location":"sensors/template-sensors/#firmware","text":"Steps to read a simple digital data: Enable system clock/ board configs. Enable the peripheral Configure on the peripheral: Pin as input As need: Pull-Up/ Pull-Down Read the data","title":"Firmware"},{"location":"sensors/template-sensors/#code","text":"Microchip SAME70 Firmware example for SAME70 with internal Pull-Up to read a push button connected to the pin PA11 . mbed Example for mbed with internal Pull-Up to read a push button connected to the pin SW2 . Reference: https://os.mbed.com/docs/mbed-os/v6.2/apis/digitalin.html #include \"mbed.h\" DigitalIn but_pin ( SW2 ); // change this to the button on your board int main () { // check mypin object is initialized and connected to a pin if ( but_pin . is_connected ()) { printf ( \"mypin is connected and initialized! \\n\\r \" ); } but_pin . mode ( PullUp ); while ( 1 ) { if ( but_pin . read ()) { // button not pressed else { // button pressed } ThisThread :: sleep_for ( 250 ); } } Arduino Example for arduino with internal Pull-Up to read a push button connected to the pin 7 . Referece: https://www.arduino.cc/en/Reference/DigitalRead&usg=ALkJrhirTmK1 ... // pushbutton connected to digital pin 7 int inPin = 7 ; void setup () { // sets the digital pin 7 as input pinMode ( inPin , INPUT_PULLUP ); } void loop () { if ( digitalRead ( inPin )) { // button not pressed } else { // button pressed } }","title":"Code"}]}