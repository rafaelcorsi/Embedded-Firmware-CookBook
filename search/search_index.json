{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Embedded System Cook Book \u00b6 Ideia do livro \u00e9 de ter receitas de como desenvolver firmware para sistemas embarcados, as receitas ser\u00e3o de \"aplica\u00e7\u00f5es\", \"sensores\" e \"atuadores\" sem pensar muito no HW, mais focado para o firmware. misc sensores atuadores dsp","title":"Home"},{"location":"#embedded-system-cook-book","text":"Ideia do livro \u00e9 de ter receitas de como desenvolver firmware para sistemas embarcados, as receitas ser\u00e3o de \"aplica\u00e7\u00f5es\", \"sensores\" e \"atuadores\" sem pensar muito no HW, mais focado para o firmware. misc sensores atuadores dsp","title":"Embedded System Cook Book"},{"location":"misc/digital-input-irq/","text":"Digital Input - IRQ \u00b6 read before This complements Digital Input - Pooling . General information and hardware is describe there. The use of interruption makes the code react to event on the pin (High -> Low/ Low -> High/ High/ Low). The advantage of using interrupt is: Avoid losing information (pin value change) Prioritization of events Entering in low power mode Ever time an event occurs on the pin, the peripheral sends a signal to NVIC , hardware responsible to handle Interruptions Request (IRQ), and the NVIC acts on the CORE to disrupt the normal code flow and execute a function that is associated to this IRQ, this functions is frequently called: Handler or callbacks . When the function returns, the core goes back to the normal code flow, with no loss of data. Interruption is a little more complicated than this, please read: .... Hardware \u00b6 See Digital Input - Pooling Firmware \u00b6 Steps to enable interruption on digital pin input: Enable system clock/ board configurations. Enable the peripheral Configure the pin on peripheral: Pin as input Pull-Up/ Pull-Down (depends on HW) Configure interruption (edge/ level) Enable interruption Configure NVIC: IRQ peripheral priority Enable peripheral IRQ Write a function that will handle the interruption Example Code \u00b6 SAME70 Firmware example for SAME70 with internal Pull-Up and Falling Edge interruption to read a push button connected to the pin PA11 . Callback function but_callback will be called every time the button is pressed. #define BUT_PIO PIOA #define BUT_PIO_ID ID_PIOA #define BUT_IDX 11 #define BUT_IDX_MASK (1 << BUT_IDX) #define BUT_SETTINGS PIO_PULLUP // this function is called when button is pressed void but_callback ( void ){ } int main ( void ){ // init system sysclk_init (); // enable and configure peripheral pmc_enable_periph_clk ( BUT_PRO_ID ); pio_configure ( BUT_PIO , PIO_INPUT , BUT_IDX_MASK , BUT_SETTINGS ); // configure interruption on pin with falling edge pio_handler_set ( BUT_PIO , BUT_PIO_ID , BUT_IDX_MASK , PIO_IT_FALL_EDGE , but_callback ); // enable peripheral interruption pio_enable_interrupt ( BUT_PIO , BUT_IDX_MASK ); // set peripheral priority and enable IRQ on NVIC NVIC_SetPriority ( BUT_PIO_ID , 4 ); NVIC_EnableIRQ ( BUT_PIO_ID ); while ( 1 ){ // note that there is no code on while! // but if the button is pressed, the // function but_callback will be called by // hardware! } } Multiple events It is possible to react to multiple events on the pin, example: Falling edge and rising edge, this would create an interruption when the button is pressed and released. This interruption would leave to the same callback function but_callback , there is two way to discovery by what event you got in the function: read the actual pin value, if 1 you get on the function by a rising edge, if 0 you get by a falling edge. some peripherals can inform by a status register what triggered the IRQ. On this code: void but_callback (void){ + if (pio_get (BUT_PIO, PIO_INPUT, BUT_IDX_MASK)){ + // rising edge + } else { + // falling edge + } } // configure interruption on pin with falling edge pio_handler_set (BUT_PIO, BUT_PIO_ID, BUT_IDX_MASK, - PIO_IT_FALL_EDGE, but_callback); + PIO_IT_FALL_EDGE | PIO_IT_RISE_EDGE, but_callback); Arduino Firmware example for Arduino with internal Pull-Up and Falling Edge interruption to read a push button connected to the pin 7 . Callback function but_callback will be called every time the button is pressed. const byte interruptPin = 7 ; volatile byte state = LOW ; void setup () { pinMode ( interruptPin , INPUT_PULLUP ); attachInterrupt ( digitalPinToInterrupt ( interruptPin ), but_callback , CHANGE ); } void loop () { // note that there is no code on loop! // but if the button is pressed, the // function but_callback will be called by // hardware! } // this function is called when button is pressed void but_callback ( void ){ }","title":"Digital Input - IRQ"},{"location":"misc/digital-input-irq/#digital-input-irq","text":"read before This complements Digital Input - Pooling . General information and hardware is describe there. The use of interruption makes the code react to event on the pin (High -> Low/ Low -> High/ High/ Low). The advantage of using interrupt is: Avoid losing information (pin value change) Prioritization of events Entering in low power mode Ever time an event occurs on the pin, the peripheral sends a signal to NVIC , hardware responsible to handle Interruptions Request (IRQ), and the NVIC acts on the CORE to disrupt the normal code flow and execute a function that is associated to this IRQ, this functions is frequently called: Handler or callbacks . When the function returns, the core goes back to the normal code flow, with no loss of data. Interruption is a little more complicated than this, please read: ....","title":"Digital Input - IRQ"},{"location":"misc/digital-input-irq/#hardware","text":"See Digital Input - Pooling","title":"Hardware"},{"location":"misc/digital-input-irq/#firmware","text":"Steps to enable interruption on digital pin input: Enable system clock/ board configurations. Enable the peripheral Configure the pin on peripheral: Pin as input Pull-Up/ Pull-Down (depends on HW) Configure interruption (edge/ level) Enable interruption Configure NVIC: IRQ peripheral priority Enable peripheral IRQ Write a function that will handle the interruption","title":"Firmware"},{"location":"misc/digital-input-irq/#example-code","text":"SAME70 Firmware example for SAME70 with internal Pull-Up and Falling Edge interruption to read a push button connected to the pin PA11 . Callback function but_callback will be called every time the button is pressed. #define BUT_PIO PIOA #define BUT_PIO_ID ID_PIOA #define BUT_IDX 11 #define BUT_IDX_MASK (1 << BUT_IDX) #define BUT_SETTINGS PIO_PULLUP // this function is called when button is pressed void but_callback ( void ){ } int main ( void ){ // init system sysclk_init (); // enable and configure peripheral pmc_enable_periph_clk ( BUT_PRO_ID ); pio_configure ( BUT_PIO , PIO_INPUT , BUT_IDX_MASK , BUT_SETTINGS ); // configure interruption on pin with falling edge pio_handler_set ( BUT_PIO , BUT_PIO_ID , BUT_IDX_MASK , PIO_IT_FALL_EDGE , but_callback ); // enable peripheral interruption pio_enable_interrupt ( BUT_PIO , BUT_IDX_MASK ); // set peripheral priority and enable IRQ on NVIC NVIC_SetPriority ( BUT_PIO_ID , 4 ); NVIC_EnableIRQ ( BUT_PIO_ID ); while ( 1 ){ // note that there is no code on while! // but if the button is pressed, the // function but_callback will be called by // hardware! } } Multiple events It is possible to react to multiple events on the pin, example: Falling edge and rising edge, this would create an interruption when the button is pressed and released. This interruption would leave to the same callback function but_callback , there is two way to discovery by what event you got in the function: read the actual pin value, if 1 you get on the function by a rising edge, if 0 you get by a falling edge. some peripherals can inform by a status register what triggered the IRQ. On this code: void but_callback (void){ + if (pio_get (BUT_PIO, PIO_INPUT, BUT_IDX_MASK)){ + // rising edge + } else { + // falling edge + } } // configure interruption on pin with falling edge pio_handler_set (BUT_PIO, BUT_PIO_ID, BUT_IDX_MASK, - PIO_IT_FALL_EDGE, but_callback); + PIO_IT_FALL_EDGE | PIO_IT_RISE_EDGE, but_callback); Arduino Firmware example for Arduino with internal Pull-Up and Falling Edge interruption to read a push button connected to the pin 7 . Callback function but_callback will be called every time the button is pressed. const byte interruptPin = 7 ; volatile byte state = LOW ; void setup () { pinMode ( interruptPin , INPUT_PULLUP ); attachInterrupt ( digitalPinToInterrupt ( interruptPin ), but_callback , CHANGE ); } void loop () { // note that there is no code on loop! // but if the button is pressed, the // function but_callback will be called by // hardware! } // this function is called when button is pressed void but_callback ( void ){ }","title":"Example Code"},{"location":"misc/digital-input-pooling/","text":"Digital Input - Pooling \u00b6 Digital input output (I/O) is the most simple way to read from external world. This signal can assume only two states: On/OFF, 1 / 0 , High / Low . most common uses Buttons (push/ slider/ dip switch) Signal pulse (encoder) ... The peripheral that allows us to read a digital value is common named: Parallel I/O - PIO General-Purpose I/O - GPIO Normally this peripherals controls more than one pin and each microcontroller has several instances of the same peripheral, to control more pins. Each pin can be configured independent. Microchip SAM Microchip SAM microcontrollers called this as PIO, each instance of the PIO is called PIO A , PIO B , PIO C , ... each PIO can controll up to 32 independents pins. Hardware \u00b6 This examples shows how to read a button, but can be apply to others digital componentes. There is two way to use a button: with Pull-Up or Pull-Down. Most peripherals allow to enable a internal Pull-UP/Pull-Down resistor, with no need to connet resistores to the uC. Internal Pull-Up Best solution (reduces the risk of burning, uses fewer components) Setup: Connect button to pin and to gnd Need to configure Pull-Up on the peripheral. No need to external resistor Read 1 when not pressed and 0 when pressed. External Pull-Up Setup: Connect button to pin and to gnd Add a parallel resistor to VCC must respect max pin voltage Read 1 when not pressed and 0 when pressed. Warning You must respect the VCC of your system. Internal Pull-Down TODO Read 0 when not pressed and 1 when pressed. External Pull-Down TODO Read 0 when not pressed and 1 when pressed. Firmware \u00b6 Steps to read a simple digital data: Enable system clock/ board configs. Enable the peripheral Configure on the peripheral: Pin as input As need: Pull-Up/ Pull-Down Read the data Code \u00b6 Microchip SAME70 Firmware example for SAME70 with internal Pull-Up to read a push button connected to the pin PA11 . #define BUT_PIO PIOA #define BUT_PIO_ID ID_PIOA #define BUT_IDX 11 #define BUT_IDX_MASK (1 << BUT_IDX) #define BUT_SETTINGS PIO_PULLUP int main ( void ){ // init system sysclk_init (); // enable and configure peripheral pmc_enable_periph_clk ( BUT_PIO_ID ); pio_configure ( BUT_PIO , PIO_INPUT , BUT_IDX_MASK , BUT_SETTINGS ); while ( 1 ){ if ( pio_get ( BUT_PIO , PIO_INPUT , BUT_IDX_MASK )){ // button not pressed } else { // button pressed } } } Arduino Example for arduino with internal Pull-Up to read a push button connected to the pin 7 . Ref: https://www.arduino.cc/en/Reference/DigitalRead&usg=ALkJrhirTmK1 ... // pushbutton connected to digital pin 7 int inPin = 7 ; void setup () { // sets the digital pin 7 as input pinMode ( inPin , INPUT_PULLUP ); } void loop () { if ( digitalRead ( inPin )){ // button not pressed } else { // button pressed } }","title":"Digital Input - Pooling"},{"location":"misc/digital-input-pooling/#digital-input-pooling","text":"Digital input output (I/O) is the most simple way to read from external world. This signal can assume only two states: On/OFF, 1 / 0 , High / Low . most common uses Buttons (push/ slider/ dip switch) Signal pulse (encoder) ... The peripheral that allows us to read a digital value is common named: Parallel I/O - PIO General-Purpose I/O - GPIO Normally this peripherals controls more than one pin and each microcontroller has several instances of the same peripheral, to control more pins. Each pin can be configured independent. Microchip SAM Microchip SAM microcontrollers called this as PIO, each instance of the PIO is called PIO A , PIO B , PIO C , ... each PIO can controll up to 32 independents pins.","title":"Digital Input - Pooling"},{"location":"misc/digital-input-pooling/#hardware","text":"This examples shows how to read a button, but can be apply to others digital componentes. There is two way to use a button: with Pull-Up or Pull-Down. Most peripherals allow to enable a internal Pull-UP/Pull-Down resistor, with no need to connet resistores to the uC. Internal Pull-Up Best solution (reduces the risk of burning, uses fewer components) Setup: Connect button to pin and to gnd Need to configure Pull-Up on the peripheral. No need to external resistor Read 1 when not pressed and 0 when pressed. External Pull-Up Setup: Connect button to pin and to gnd Add a parallel resistor to VCC must respect max pin voltage Read 1 when not pressed and 0 when pressed. Warning You must respect the VCC of your system. Internal Pull-Down TODO Read 0 when not pressed and 1 when pressed. External Pull-Down TODO Read 0 when not pressed and 1 when pressed.","title":"Hardware"},{"location":"misc/digital-input-pooling/#firmware","text":"Steps to read a simple digital data: Enable system clock/ board configs. Enable the peripheral Configure on the peripheral: Pin as input As need: Pull-Up/ Pull-Down Read the data","title":"Firmware"},{"location":"misc/digital-input-pooling/#code","text":"Microchip SAME70 Firmware example for SAME70 with internal Pull-Up to read a push button connected to the pin PA11 . #define BUT_PIO PIOA #define BUT_PIO_ID ID_PIOA #define BUT_IDX 11 #define BUT_IDX_MASK (1 << BUT_IDX) #define BUT_SETTINGS PIO_PULLUP int main ( void ){ // init system sysclk_init (); // enable and configure peripheral pmc_enable_periph_clk ( BUT_PIO_ID ); pio_configure ( BUT_PIO , PIO_INPUT , BUT_IDX_MASK , BUT_SETTINGS ); while ( 1 ){ if ( pio_get ( BUT_PIO , PIO_INPUT , BUT_IDX_MASK )){ // button not pressed } else { // button pressed } } } Arduino Example for arduino with internal Pull-Up to read a push button connected to the pin 7 . Ref: https://www.arduino.cc/en/Reference/DigitalRead&usg=ALkJrhirTmK1 ... // pushbutton connected to digital pin 7 int inPin = 7 ; void setup () { // sets the digital pin 7 as input pinMode ( inPin , INPUT_PULLUP ); } void loop () { if ( digitalRead ( inPin )){ // button not pressed } else { // button pressed } }","title":"Code"},{"location":"misc/digital-output/","text":"Digital Output \u00b6 Digital output is the most simple way to control the external world. This signal can assume only two states: On/OFF, 1 / 0 , High / Low . most common uses LED DC Motor Buzzer ... The peripheral that allows us to read a digital value is common named: Parallel I/O - PIO General-Purpose I/O - GPIO Peripheral Read more about this peripheral on Peripheral-PIO . Hardware \u00b6 This examples shows how to control a LED, but can be apply to others digital components. This example shows on how to control a LED with a microcontroller, the series resistor limits the electric current. Drive in Best solution (reduces the risk of burning as normally input accept electric current is higher than output current) Connect LED to resistor to VCC Write 0 to pin light up LED, 1 turn off. Drive out Warning You must respect the VCC of your system. You must check the resistor value to your system. Firmware \u00b6 Steps to simple control a PIO pin: Enable system clock/ board configs. Enable the peripheral Configure the Pin as output Control pin (High/ Low) Example Code \u00b6 Microchip SAME70 Example for SAME70 blink an LED with drive in connection on pin `PC8``. #define LED_PIO PIOC #define LED_PIO_ID ID_PIOC #define LED_IDX 8 #define LED_IDX_MASK (1 << LED_IDX) #define LED_CONFIG PIO_DEFAULT int main ( void ){ sysclk_init (); // initialize digital pin LED_IDX as an output. pmc_enable_periph_clk ( LED_PIO_ID ); pio_configure ( LED_PIO , PIO_OUTPUT_0 , LED_IDX_MASK , PIO_DEFAULT ); while ( 1 ){ // drive pin low - turns led on pio_clear ( LED_PIO , LED_IDX_MASK ); delay_ms ( 100 ); // drive pin high - turns led off pio_set ( LED_PIO , LED_IDX_MASK ); delay_ms ( 100 ); } Arduino // pushbutton connected to digital pin 7 int LED_PIN = 5 ; void setup () { // initialize digital pin LED_PIN as an output. pinMode ( LED_PIN , OUTPUT ); } void loop () { // drive pin low - turns led on digitalWrite ( LED_PIN , LOW ); delay ( 100 ); // drive pin high - turns led off digitalWrite ( LED_PIN , HIGH ); delay ( 100 ); }","title":"Digital Output"},{"location":"misc/digital-output/#digital-output","text":"Digital output is the most simple way to control the external world. This signal can assume only two states: On/OFF, 1 / 0 , High / Low . most common uses LED DC Motor Buzzer ... The peripheral that allows us to read a digital value is common named: Parallel I/O - PIO General-Purpose I/O - GPIO Peripheral Read more about this peripheral on Peripheral-PIO .","title":"Digital Output"},{"location":"misc/digital-output/#hardware","text":"This examples shows how to control a LED, but can be apply to others digital components. This example shows on how to control a LED with a microcontroller, the series resistor limits the electric current. Drive in Best solution (reduces the risk of burning as normally input accept electric current is higher than output current) Connect LED to resistor to VCC Write 0 to pin light up LED, 1 turn off. Drive out Warning You must respect the VCC of your system. You must check the resistor value to your system.","title":"Hardware"},{"location":"misc/digital-output/#firmware","text":"Steps to simple control a PIO pin: Enable system clock/ board configs. Enable the peripheral Configure the Pin as output Control pin (High/ Low)","title":"Firmware"},{"location":"misc/digital-output/#example-code","text":"Microchip SAME70 Example for SAME70 blink an LED with drive in connection on pin `PC8``. #define LED_PIO PIOC #define LED_PIO_ID ID_PIOC #define LED_IDX 8 #define LED_IDX_MASK (1 << LED_IDX) #define LED_CONFIG PIO_DEFAULT int main ( void ){ sysclk_init (); // initialize digital pin LED_IDX as an output. pmc_enable_periph_clk ( LED_PIO_ID ); pio_configure ( LED_PIO , PIO_OUTPUT_0 , LED_IDX_MASK , PIO_DEFAULT ); while ( 1 ){ // drive pin low - turns led on pio_clear ( LED_PIO , LED_IDX_MASK ); delay_ms ( 100 ); // drive pin high - turns led off pio_set ( LED_PIO , LED_IDX_MASK ); delay_ms ( 100 ); } Arduino // pushbutton connected to digital pin 7 int LED_PIN = 5 ; void setup () { // initialize digital pin LED_PIN as an output. pinMode ( LED_PIN , OUTPUT ); } void loop () { // drive pin low - turns led on digitalWrite ( LED_PIN , LOW ); delay ( 100 ); // drive pin high - turns led off digitalWrite ( LED_PIN , HIGH ); delay ( 100 ); }","title":"Example Code"},{"location":"misc/digital_out/","text":"Digital Output \u00b6 Digital output is the most simple way to control the external world. This signal can assume only two states: On/OFF, 1 / 0 , High / Low . most common uses LED DC Motor Buzzer ... Normally this peripherals controls more than one pin and each microcontroller has several instances of the same peripheral, to control more pins. Each pin can be configured independent. Microchip SAM Microchip SAM microcontrollers called this as PIO, each instance of the PIO is called PIO A , PIO B , PIO C , ... each PIO can controll up to 32 independents pins. Hardware \u00b6 This examples shows how to control a LED, but can be apply to others digital componentes. Firmware \u00b6 Steps to simple control a PIO pin: Enable system clock/ board configs. Enable the peripheral Configure the Pin as output Write to pin Example \u00b6","title":"Digital Output"},{"location":"misc/digital_out/#digital-output","text":"Digital output is the most simple way to control the external world. This signal can assume only two states: On/OFF, 1 / 0 , High / Low . most common uses LED DC Motor Buzzer ... Normally this peripherals controls more than one pin and each microcontroller has several instances of the same peripheral, to control more pins. Each pin can be configured independent. Microchip SAM Microchip SAM microcontrollers called this as PIO, each instance of the PIO is called PIO A , PIO B , PIO C , ... each PIO can controll up to 32 independents pins.","title":"Digital Output"},{"location":"misc/digital_out/#hardware","text":"This examples shows how to control a LED, but can be apply to others digital componentes.","title":"Hardware"},{"location":"misc/digital_out/#firmware","text":"Steps to simple control a PIO pin: Enable system clock/ board configs. Enable the peripheral Configure the Pin as output Write to pin","title":"Firmware"},{"location":"misc/digital_out/#example","text":"","title":"Example"}]}